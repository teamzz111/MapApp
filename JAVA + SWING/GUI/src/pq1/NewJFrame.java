package pq1;

import java.util.ArrayList;
import java.util.List;
import java.util.PriorityQueue;

/**
 *
 * @author Burzum-PC
 */
public class NewJFrame extends javax.swing.JFrame {

    public boolean buttonpressed;

    /**
     * Creates new form NewJFrame
     */
    public NewJFrame() {
        initComponents();
        setTitle("Ciclorutas");

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        ComboIni = new javax.swing.JComboBox<>();
        ComboFin = new javax.swing.JComboBox<>();
        jButton1 = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jLabel2 = new javax.swing.JLabel();
        jSeparator1 = new javax.swing.JSeparator();
        jLabel3 = new javax.swing.JLabel();
        jLabel1 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        ComboIni.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "(0) Seleccione un Inicio", "(1) Carrera 95 A - Calle 73 Sur", "(2) Carrera 90 - Calle 41 Sur", "(3) Carrera 92 - Calle 6d", "(4) Carrera 104 # 16 - Sa", "(5) Carrera 103 - Calle 26", "(6) Calle 20 - Carrera 86", "(7) Carrea 86 - Calle 6d", "(8) Calle 40b Sur #86", "(9) Avenida Boyaca con Calle 6", "(10) Avenida Boyaca con Autopista Sur", "(11) Avenida Boyaca con Carrera 24", "(12) Autopista Sur con Calle 59 Sur ", "(13) Calle 26 con Boyaca", "(14) Calle 26 con Carrera 68", "(15) Calle 26 # 29a - 41", "(16) Calle 13 # 2a - 91", "(17) Calle 13 # 12 - 2", "(18) Carrera 10 # 23 - 6", "(19) Avenida ciudad de Cali - Calle 63", "(20) Calle 63 con Carrera 112", "(21) Avenida Boyaca con Calle 63", "(22) Avenida Calle 80 - Carrera 86", "(23) Avenida Calle 80 - Carrera 119", "(24) Centro Comercial Titan Plaza", "(25) Carrera 68 # 79 - 11", "(26) Puente Troncal Calle 80", "(27) Avenida Calle 100 con Carrera 11", "(28) Avenida carrera 30 con Calle 92", "(29) Bogota La caro # 192 - 2a", "(30) Calle 200 - Carrera 45", "(31) Avenida Boayaca # 169d - 1" }));

        ComboFin.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "(0) Seleccione un destino", "(1) Carrera 95 A - Calle 73 Sur", "(2) Carrera 90 - Calle 41 Sur", "(3) Carrera 92 - Calle 6d", "(4) Carrera 104 # 16 - Sa", "(5) Carrera 103 - Calle 26", "(6) Calle 20 - Carrera 86", "(7) Carrea 86 - Calle 6d", "(8) Calle 40b Sur #86", "(9) Avenida Boyaca con Calle 6", "(10) Avenida Boyaca con Autopista Sur", "(11) Avenida Boyaca con Carrera 24", "(12) Autopista Sur con Calle 59 Sur ", "(13) Calle 26 con Boyaca", "(14) Calle 26 con Carrera 68", "(15) Calle 26 # 29a - 41", "(16) Calle 13 # 2a - 91", "(17) Calle 13 # 12 - 2", "(18) Carrera 10 # 23 - 6", "(19) Avenida ciudad de Cali - Calle 63", "(20) Calle 63 con Carrera 112", "(21) Avenida Boyaca con Calle 63", "(22) Avenida Calle 80 - Carrera 86", "(23) Avenida Calle 80 - Carrera 119", "(24) Centro Comercial Titan Plaza", "(25) Carrera 68 # 79 - 11", "(26) Puente Troncal Calle 80", "(27) Avenida Calle 100 con Carrera 11", "(28) Avenida carrera 30 con Calle 92", "(29) Bogota La caro # 192 - 2a", "(30) Calle 200 - Carrera 45", "(31) Avenida Boayaca # 169d - 1" }));

        jButton1.setText("Calcular rutas.");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jTextArea1.setColumns(20);
        jTextArea1.setFont(new java.awt.Font("Tahoma", 0, 13)); // NOI18N
        jTextArea1.setRows(5);
        jScrollPane1.setViewportView(jTextArea1);

        jLabel2.setIcon(new javax.swing.ImageIcon(getClass().getResource("/pq1/mapaBog.png"))); // NOI18N

        jLabel3.setIcon(new javax.swing.ImageIcon(getClass().getResource("/pq1/256px-BOG187.JPG"))); // NOI18N

        jLabel1.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel1.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel1.setText("Historial de rutas");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                .addComponent(jScrollPane1)
                                .addGroup(layout.createSequentialGroup()
                                    .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 256, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addComponent(jSeparator1, javax.swing.GroupLayout.DEFAULT_SIZE, 1, Short.MAX_VALUE)))
                            .addComponent(jLabel3)))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(ComboIni, javax.swing.GroupLayout.PREFERRED_SIZE, 317, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(ComboFin, javax.swing.GroupLayout.PREFERRED_SIZE, 312, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButton1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(ComboIni)
                    .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 35, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(ComboFin))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel2)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel3)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 12, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 19, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 693, Short.MAX_VALUE)))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // TODO add your handling code here:
        jTextArea1.append("\n");
        jTextArea1.append("*****************\n Posibles rutas."); 
        boton();
         


    }//GEN-LAST:event_jButton1ActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {

        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Windows".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new NewJFrame().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JComboBox<String> ComboFin;
    private javax.swing.JComboBox<String> ComboIni;
    private javax.swing.JButton jButton1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JTextArea jTextArea1;
    // End of variables declaration//GEN-END:variables

    public void boton() {
        int E = 41, origen, destino, inicial, V = 31;// v es la cantidad de nodo y e son los enlaces
        int pesototal;
        int i = ComboIni.getSelectedIndex();
        int d = ComboFin.getSelectedIndex();

        Dijkstra dijkstraAlgorithm = new Dijkstra(V);

        // CAMINOS ASCENDENTES
        dijkstraAlgorithm.addEdge(1, 2, 4, true);
        dijkstraAlgorithm.addEdge(2, 3, 2, true);
        dijkstraAlgorithm.addEdge(3, 4, 3, true);
        dijkstraAlgorithm.addEdge(4, 5, 3, true);
        dijkstraAlgorithm.addEdge(5, 6, 2, true);
        dijkstraAlgorithm.addEdge(6, 7, 7, true);
        dijkstraAlgorithm.addEdge(3, 7, 1, true);
        dijkstraAlgorithm.addEdge(7, 8, 2, true);
        dijkstraAlgorithm.addEdge(8, 2, 2, true);
        dijkstraAlgorithm.addEdge(7, 9, 3, true);
        dijkstraAlgorithm.addEdge(9, 10, 5, true);
        dijkstraAlgorithm.addEdge(10, 11, 4, true);
        dijkstraAlgorithm.addEdge(10, 12, 4, true);
        dijkstraAlgorithm.addEdge(6, 13, 3, true);
        dijkstraAlgorithm.addEdge(9, 13, 7, true);
        dijkstraAlgorithm.addEdge(13, 14, 2, true);
        dijkstraAlgorithm.addEdge(14, 15, 4, true);
        dijkstraAlgorithm.addEdge(15, 16, 2, true);
        dijkstraAlgorithm.addEdge(10, 16, 7, true);
        dijkstraAlgorithm.addEdge(9, 16, 6, true);
        dijkstraAlgorithm.addEdge(16, 17, 2, true);
        dijkstraAlgorithm.addEdge(17, 18, 1, true);
        dijkstraAlgorithm.addEdge(15, 18, 9, true);
        dijkstraAlgorithm.addEdge(6, 19, 1, true);
        dijkstraAlgorithm.addEdge(19, 20, 3, true);
        dijkstraAlgorithm.addEdge(13, 21, 2, true);
        dijkstraAlgorithm.addEdge(19, 21, 2, true);
        dijkstraAlgorithm.addEdge(19, 22, 3, true);
        dijkstraAlgorithm.addEdge(22, 23, 4, true);
        dijkstraAlgorithm.addEdge(22, 24, 2, true);
        dijkstraAlgorithm.addEdge(21, 24, 3, true);
        dijkstraAlgorithm.addEdge(14, 25, 4, true);
        dijkstraAlgorithm.addEdge(24, 25, 2, true);
        dijkstraAlgorithm.addEdge(25, 26, 2, true);
        dijkstraAlgorithm.addEdge(15, 26, 6, true);
        dijkstraAlgorithm.addEdge(18, 27, 9, true);
        dijkstraAlgorithm.addEdge(26, 28, 1, true);
        dijkstraAlgorithm.addEdge(28, 29, 10, true);
        dijkstraAlgorithm.addEdge(27, 28, 4, true);
        dijkstraAlgorithm.addEdge(27, 30, 11, true);
        dijkstraAlgorithm.addEdge(24, 31, 8, true);

        // CAMINOS INVERSOS
        dijkstraAlgorithm.addEdge(2, 1, 4, true);
        dijkstraAlgorithm.addEdge(3, 2, 2, true);
        dijkstraAlgorithm.addEdge(4, 3, 3, true);
        dijkstraAlgorithm.addEdge(5, 4, 3, true);
        dijkstraAlgorithm.addEdge(6, 5, 2, true);
        dijkstraAlgorithm.addEdge(7, 6, 7, true);
        dijkstraAlgorithm.addEdge(7, 3, 1, true);
        dijkstraAlgorithm.addEdge(8, 7, 2, true);
        dijkstraAlgorithm.addEdge(2, 8, 2, true);
        dijkstraAlgorithm.addEdge(9, 7, 3, true);
        dijkstraAlgorithm.addEdge(10, 9, 5, true);
        dijkstraAlgorithm.addEdge(11, 10, 4, true);
        dijkstraAlgorithm.addEdge(12, 10, 4, true);
        dijkstraAlgorithm.addEdge(13, 6, 3, true);
        dijkstraAlgorithm.addEdge(13, 9, 7, true);
        dijkstraAlgorithm.addEdge(14, 13, 2, true);
        dijkstraAlgorithm.addEdge(15, 14, 4, true);
        dijkstraAlgorithm.addEdge(16, 15, 2, true);
        dijkstraAlgorithm.addEdge(16, 10, 7, true);
        dijkstraAlgorithm.addEdge(16, 9, 6, true);
        dijkstraAlgorithm.addEdge(17, 16, 2, true);
        dijkstraAlgorithm.addEdge(18, 17, 1, true);
        dijkstraAlgorithm.addEdge(18, 15, 9, true);
        dijkstraAlgorithm.addEdge(19, 6, 1, true);
        dijkstraAlgorithm.addEdge(20, 19, 3, true);
        dijkstraAlgorithm.addEdge(21, 13, 2, true);
        dijkstraAlgorithm.addEdge(21, 19, 2, true);
        dijkstraAlgorithm.addEdge(22, 19, 3, true);
        dijkstraAlgorithm.addEdge(23, 22, 4, true);
        dijkstraAlgorithm.addEdge(24, 22, 2, true);
        dijkstraAlgorithm.addEdge(24, 21, 3, true);
        dijkstraAlgorithm.addEdge(25, 14, 4, true);
        dijkstraAlgorithm.addEdge(25, 24, 2, true);
        dijkstraAlgorithm.addEdge(26, 25, 2, true);
        dijkstraAlgorithm.addEdge(26, 15, 6, true);
        dijkstraAlgorithm.addEdge(27, 18, 9, true);
        dijkstraAlgorithm.addEdge(28, 26, 1, true);
        dijkstraAlgorithm.addEdge(29, 28, 10, true);
        dijkstraAlgorithm.addEdge(28, 27, 4, true);
        dijkstraAlgorithm.addEdge(30, 27, 11, true);
        dijkstraAlgorithm.addEdge(31, 24, 8, true);

//        Scanner sc = new Scanner( System.in );      //para lectura de datos                
//        System.out.print("Ingrese el vertice inicial: ");
//        inicial = sc.nextInt();
        dijkstraAlgorithm.dijkstra(i);
        dijkstraAlgorithm.printShortestPath();
    }

    class Dijkstra {

        //similar a los defines de C++
        private final int MAX = 10005;  //maximo numero de vÃ©rtices
        private final int INF = 1 << 30;  //definimos un valor grande que represente la distancia infinita inicial, basta conque sea superior al maximo valor del peso en alguna de las aristas

        private List< List< Node>> ady = new ArrayList< List< Node>>(); //lista de adyacencia
        private int distancia[] = new int[MAX];          //distancia[ u ] distancia de vÃ©rtice inicial a vÃ©rtice con ID = u
        private boolean visitado[] = new boolean[MAX];   //para vÃ©rtices visitados
        private PriorityQueue< Node> Q = new PriorityQueue<Node>(); //priority queue propia de Java, usamos el comparador definido para que el de menor valor este en el tope
        private int V;                                      //numero de vertices
        private int previo[] = new int[MAX];              //para la impresion de caminos
        private boolean dijkstraEjecutado;

        Dijkstra(int V) {
            this.V = V;
            for (int i = 0; i <= V; ++i) {
                ady.add(new ArrayList<Node>()); //inicializamos lista de adyacencia
            }
            dijkstraEjecutado = false;
        }

        //En el caso de java usamos una clase que representara el pair de C++
        class Node implements Comparable<Node> {

            int first, second;

            Node(int d, int p) {                          //constructor
                this.first = d;
                this.second = p;
            }

            public int compareTo(Node other) {              //es necesario definir un comparador para el correcto funcionamiento del PriorityQueue
                if (second > other.second) {
                    return 1;
                }
                if (second == other.second) {
                    return 0;
                }
                return -1;
            }
        };

        //funciÃ³n de inicializaciÃ³n
        private void init() {
            for (int i = 0; i <= V; ++i) {
                distancia[i] = INF;  //inicializamos todas las distancias con valor infinito
                visitado[i] = false; //inicializamos todos los vÃ©rtices como no visitados
                previo[i] = -1;      //inicializamos el previo del vertice i con -1
            }
        }

        //Paso de relajacion
        private void relajacion(int actual, int adyacente, int peso) {
            //Si la distancia del origen al vertice actual + peso de su arista es menor a la distancia del origen al vertice adyacente
            if (distancia[actual] + peso < distancia[adyacente]) {
                distancia[adyacente] = distancia[actual] + peso;  //relajamos el vertice actualizando la distancia
                previo[adyacente] = actual;                         //a su vez actualizamos el vertice previo
                Q.add(new Node(adyacente, distancia[adyacente])); //agregamos adyacente a la cola de prioridad
            }
        }

        void dijkstra(int inicial) {
            init(); //inicializamos nuestros arreglos
            Q.add(new Node(inicial, 0)); //Insertamos el vÃ©rtice inicial en la Cola de Prioridad
            distancia[inicial] = 0;      //Este paso es importante, inicializamos la distancia del inicial como 0
            int actual, adyacente, peso;
            while (!Q.isEmpty()) {                   //Mientras cola no este vacia
                actual = Q.element().first;            //Obtengo de la cola el nodo con menor peso, en un comienzo serÃ¡ el inicial
                Q.remove();                           //Sacamos el elemento de la cola
                if (visitado[actual]) {
                    continue; //Si el vÃ©rtice actual ya fue visitado entonces sigo sacando elementos de la cola
                }
                visitado[actual] = true;         //Marco como visitado el vÃ©rtice actual

                for (int i = 0; i < ady.get(actual).size(); ++i) { //reviso sus adyacentes del vertice actual
                    adyacente = ady.get(actual).get(i).first;   //id del vertice adyacente
                    peso = ady.get(actual).get(i).second;        //peso de la arista que une actual con adyacente ( actual , adyacente )
                    if (!visitado[adyacente]) {        //si el vertice adyacente no fue visitado
                        relajacion(actual, adyacente, peso); //realizamos el paso de relajacion
                    }
                }
            }
            
            
            
            
            
            
            System.out.printf( "Distancias mas cortas iniciando en vertice %d\n" , inicial );
            System.out.printf("Vertice %d , distancia mas corta = %d\n" , ComboFin.getSelectedIndex() , distancia[ ComboFin.getSelectedIndex() ] );
        
            jTextArea1.append("\n Se ha encontrado una ruta \n de ~ "+String.valueOf(distancia[ ComboFin.getSelectedIndex() ])+" km si usted mantiene \n una velocidad de ~ 14 km/h \n se demorara "  );
            if(distancia[ ComboFin.getSelectedIndex() ]==0){
                jTextArea1.append("nada porque \n usted ya esta en su destino.");
            }
            if(distancia[ ComboFin.getSelectedIndex() ]<=10 && distancia[ ComboFin.getSelectedIndex() ]!=0){
                jTextArea1.append("de 20 a 45 minutos.");
            }
            if(distancia[ ComboFin.getSelectedIndex() ]<=20 && distancia[ ComboFin.getSelectedIndex() ]>10){
                jTextArea1.append("de 45 minutos a \n hora y media.");
            }
             if(distancia[ ComboFin.getSelectedIndex() ]<=30 && distancia[ ComboFin.getSelectedIndex() ]>20){
                jTextArea1.append("de hora y media a \n dos horas.");
            }
             if(distancia[ ComboFin.getSelectedIndex() ]<=40 && distancia[ ComboFin.getSelectedIndex() ]>30){
                jTextArea1.append("de dos horas a \n dos horas y media.");
            }
            
            
//            for( int i = 1 ; i <= V ; ++i ){
//            System.out.printf("Vertice %d , distancia mas corta = %d\n" , i , distancia[ i ] );
//            }
            dijkstraEjecutado = true;
        }

        void addEdge(int origen, int destino, int peso, boolean dirigido) {
            ady.get(origen).add(new Node(destino, peso));    //grafo diridigo
            if (!dirigido) {
                ady.get(destino).add(new Node(origen, peso)); //no dirigido
            }
        }

        void printShortestPath() {
            if (!dijkstraEjecutado) {
                System.out.println("Es necesario ejecutar el algorithmo de Dijkstra antes de poder imprimir el camino mas corto");
                return;
            }
            //Scanner sc = new Scanner( System.in );      //para lectura de datos
            //System.out.printf("Ingrese vertice destino: ");

            int destino = ComboFin.getSelectedIndex();
            //destino = sc.nextInt();

            jTextArea1.append("\n");

            print(destino);

            jTextArea1.append("\n");
        }

        //Impresion del camino mas corto desde el vertice inicial y final ingresados
        void print(int destino) {
            if (previo[destino] != -1) //si aun poseo un vertice previo
            {
                print(previo[destino]);  //recursivamente sigo explorando
            }
            //System.out.printf("%d ", destino);     //terminada la recursion imprimo los vertices recorridos

            //jTextArea1.append(String.valueOf(destino) + "\n");
            jTextArea1.append("\n");
            
            if (destino == 1) {
                jTextArea1.append("(1) Carrera 95 A - Calle 73 Sur");
            }
            if (destino == 2) {
                jTextArea1.append("(2) Carrera 90 - Calle 41 Sur");
            }
            if (destino == 3) {
                jTextArea1.append("(3) Carrera 92 - Calle 6d");
            }
            if (destino == 4) {
                jTextArea1.append("(4) Carrera 104 # 16 - Sa");
            }
            if (destino == 5) {
                jTextArea1.append("(5) Carrera 103 - Calle 26");
            }
            if (destino == 6) {
                jTextArea1.append("(6) Calle 20 - Carrera 86");
            }
            if (destino == 7) {
                jTextArea1.append("(7) Carrea 86 - Calle 6d");
            }
            if (destino == 8) {
                jTextArea1.append("(8) Calle 40b Sur #86");
            }
            if (destino == 9) {
                jTextArea1.append("(9) Avenida Boyaca con Calle 6");
            }
            if (destino == 10) {
                jTextArea1.append("(10) Avenida Boyaca con Autopista Sur");
            }
            if (destino == 11) {
                jTextArea1.append("(11) Avenida Boyaca con Carrera 24");
            }
            if (destino == 12) {
                jTextArea1.append("(12) Autopista Sur con Calle 59 Sur ");
            }
            if (destino == 13) {
                jTextArea1.append("(13) Calle 26 con Boyaca");
            }
            if (destino == 14) {
                jTextArea1.append("(14) Calle 26 con Carrera 68");
            }
            if (destino == 15) {
                jTextArea1.append("(15) Calle 26 # 29a - 41");
            }
            if (destino == 16) {
                jTextArea1.append("(16) Calle 13 # 2a - 91");
            }
            if (destino == 17) {
                jTextArea1.append("(17) Calle 13 # 12 - 2");
            }
            if (destino == 18) {
                jTextArea1.append("(18) Carrera 10 # 23 - 6");
            }
            if (destino == 19) {
                jTextArea1.append("(19) Avenida ciudad de Cali - Calle 63");
            }
            if (destino == 20) {
                jTextArea1.append("(20) Calle 63 con Carrera 112");
            }
            if (destino == 21) {
                jTextArea1.append("(21) Avenida Boyaca con Calle 63");
            }
            if (destino == 22) {
                jTextArea1.append("(22) Avenida Calle 80 - Carrera 86");
            }
            if (destino == 23) {
                jTextArea1.append("(23) Avenida Calle 80 - Carrera 119");
            }
            if (destino == 24) {
                jTextArea1.append("(24) Centro Comercial Titan Plaza");
            }
            if (destino == 25) {
                jTextArea1.append("(25) Carrera 68 # 79 - 11");
            }
            if (destino == 26) {
                jTextArea1.append("(26) Puente Troncal Calle 80");
            }
            if (destino == 27) {
                jTextArea1.append("(27) Avenida Calle 100 con Carrera 11");
            }
            if (destino == 28) {
                jTextArea1.append("(28) Avenida carrera 30 con Calle 92");
            }
            if (destino == 29) {
                jTextArea1.append("(29) Bogota La caro # 192 - 2a");
            }
            if (destino == 30) {
                jTextArea1.append("(30) Calle 200 - Carrera 45");
            }
            if (destino == 31) {
                jTextArea1.append("(31) Avenida Boayaca # 169d - 1");
            }

        }

        public int getNumberOfVertices() {
            return V;
        }

        public void setNumberOfVertices(int numeroDeVertices) {
            V = numeroDeVertices;
        }
    }

}
